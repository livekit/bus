// Code generated by protoc-gen-psrpc v0.0.1, DO NOT EDIT.
// source: my_service.proto

package my_service

import context "context"

import psrpc1 "github.com/livekit/psrpc"

// ==========================
// MyService Client Interface
// ==========================

type MyServiceClient interface {
	// A normal RPC - one request, one response. The request will be handled by the first available server
	NormalRPC(context.Context, *MyRequest, ...psrpc1.RequestOpt) (*MyResponse, error)

	// An RPC with a server affinity function for handler selection.
	IntensiveRPC(context.Context, *MyRequest, ...psrpc1.RequestOpt) (*MyResponse, error)

	// A multi-rpc - a client will send one request, and receive one response each from every server
	GetStats(context.Context, *MyRequest, ...psrpc1.RequestOpt) (<-chan *psrpc1.Response[*MyResponse], error)

	// An RPC with topics - a client can send one request, and receive one response from each server in one region
	GetRegionStats(context.Context, string, *MyRequest, ...psrpc1.RequestOpt) (<-chan *psrpc1.Response[*MyResponse], error)

	// A queue subscription - even if multiple clients are subscribed, only one will receive this update.
	// The request parameter (Ignored) will be ignored when generating go files.
	SubscribeProcessUpdate(context.Context) (psrpc1.Subscription[*MyUpdate], error)

	// A subscription with topics - every client subscribed to the topic will receive every update.
	// The request parameter (Ignored) will be ignored when generating go files.
	SubscribeUpdateRegionState(context.Context, string) (psrpc1.Subscription[*MyUpdate], error)
}

// ==============================
// MyService ServerImpl Interface
// ==============================

type MyServiceServerImpl interface {
	// A normal RPC - one request, one response. The request will be handled by the first available server
	NormalRPC(context.Context, *MyRequest) (*MyResponse, error)

	// An RPC with a server affinity function for handler selection.
	IntensiveRPC(context.Context, *MyRequest) (*MyResponse, error)
	IntensiveRPCAffinity(*MyRequest) float32

	// A multi-rpc - a client will send one request, and receive one response each from every server
	GetStats(context.Context, *MyRequest) (*MyResponse, error)

	// An RPC with topics - a client can send one request, and receive one response from each server in one region
	GetRegionStats(context.Context, *MyRequest) (*MyResponse, error)
}

// ==========================
// MyService Server Interface
// ==========================

type MyServiceServer interface {
	// An RPC with topics - a client can send one request, and receive one response from each server in one region
	RegisterGetRegionStatsTopic(string) error
	DeregisterGetRegionStatsTopic(string) error

	// A queue subscription - even if multiple clients are subscribed, only one will receive this update.
	// The request parameter (Ignored) will be ignored when generating go files.
	PublishProcessUpdate(context.Context, *MyUpdate) error

	// A subscription with topics - every client subscribed to the topic will receive every update.
	// The request parameter (Ignored) will be ignored when generating go files.
	PublishUpdateRegionState(context.Context, string, *MyUpdate) error
}

// ================
// MyService Client
// ================

type myServiceClient struct {
	client psrpc1.RPCClient
}

// NewMyServiceClient creates a psrpc client that implements the MyServiceClient interface.
func NewMyServiceClient(clientID string, bus psrpc1.MessageBus, opts ...psrpc1.ClientOpt) (MyServiceClient, error) {
	rpcClient, err := psrpc1.NewRPCClient("MyService", clientID, bus, opts...)
	if err != nil {
		return nil, err
	}

	return &myServiceClient{
		client: rpcClient,
	}, nil
}

func (c *myServiceClient) NormalRPC(ctx context.Context, req *MyRequest, opts ...psrpc1.RequestOpt) (*MyResponse, error) {
	return psrpc1.RequestTopicSingle[*MyResponse](ctx, c.client, "NormalRPC", "", req, opts...)
}

func (c *myServiceClient) IntensiveRPC(ctx context.Context, req *MyRequest, opts ...psrpc1.RequestOpt) (*MyResponse, error) {
	return psrpc1.RequestTopicSingle[*MyResponse](ctx, c.client, "IntensiveRPC", "", req, opts...)
}

func (c *myServiceClient) GetStats(ctx context.Context, req *MyRequest, opts ...psrpc1.RequestOpt) (<-chan *psrpc1.Response[*MyResponse], error) {
	return psrpc1.RequestTopicAll[*MyResponse](ctx, c.client, "GetStats", "", req, opts...)
}

func (c *myServiceClient) GetRegionStats(ctx context.Context, topic string, req *MyRequest, opts ...psrpc1.RequestOpt) (<-chan *psrpc1.Response[*MyResponse], error) {
	return psrpc1.RequestTopicAll[*MyResponse](ctx, c.client, "GetRegionStats", topic, req, opts...)
}

func (c *myServiceClient) SubscribeProcessUpdate(ctx context.Context) (psrpc1.Subscription[*MyUpdate], error) {
	return psrpc1.SubscribeTopicQueue[*MyUpdate](ctx, c.client, "ProcessUpdate", "")
}

func (c *myServiceClient) SubscribeUpdateRegionState(ctx context.Context, topic string) (psrpc1.Subscription[*MyUpdate], error) {
	return psrpc1.SubscribeTopic[*MyUpdate](ctx, c.client, "UpdateRegionState", topic)
}

// ================
// MyService Server
// ================

type myServiceServer struct {
	svc MyServiceServerImpl
	rpc psrpc1.RPCServer
}

// NewMyServiceServer builds a RPCServer that can be used to handle
// requests that are routed to the right method in the provided svc implementation.
func NewMyServiceServer(serverID string, svc MyServiceServerImpl, bus psrpc1.MessageBus, opts ...psrpc1.ServerOpt) (MyServiceServer, error) {
	rpcServer := psrpc1.NewRPCServer("MyService", serverID, bus, opts...)

	var err error
	err = rpcServer.RegisterHandler(psrpc1.NewHandler("NormalRPC", svc.NormalRPC))
	if err != nil {
		rpcServer.Close()
		return nil, err
	}

	err = rpcServer.RegisterHandler(psrpc1.NewHandlerWithAffinity("IntensiveRPC", svc.IntensiveRPC, svc.IntensiveRPCAffinity))
	if err != nil {
		rpcServer.Close()
		return nil, err
	}

	err = rpcServer.RegisterHandler(psrpc1.NewHandler("GetStats", svc.GetStats))
	if err != nil {
		rpcServer.Close()
		return nil, err
	}

	return &myServiceServer{
		svc: svc,
		rpc: rpcServer,
	}, nil
}

func (s *myServiceServer) RegisterGetRegionStatsTopic(topic string) error {
	return s.rpc.RegisterHandler(psrpc1.NewTopicHandler("GetRegionStats", topic, s.svc.GetRegionStats))
}

func (s *myServiceServer) DeregisterGetRegionStatsTopic(topic string) error {
	return s.rpc.DeregisterTopic("GetRegionStats", topic)
}

func (s *myServiceServer) PublishProcessUpdate(ctx context.Context, msg *MyUpdate) error {
	return s.rpc.PublishTopic(ctx, "ProcessUpdate", "", msg)
}

func (s *myServiceServer) PublishUpdateRegionState(ctx context.Context, topic string, msg *MyUpdate) error {
	return s.rpc.PublishTopic(ctx, "UpdateRegionState", topic, msg)
}

var psrpcFileDescriptor0 = []byte{
	// 288 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x93, 0x4f, 0x4e, 0xf3, 0x30,
	0x10, 0xc5, 0xe5, 0x4f, 0x1f, 0xc5, 0x9d, 0xb6, 0x28, 0x78, 0x55, 0x65, 0x05, 0x59, 0xf2, 0xc7,
	0x48, 0x70, 0x03, 0x58, 0x54, 0x5d, 0x14, 0x55, 0xa9, 0xd8, 0xb0, 0x41, 0x21, 0x1d, 0x95, 0x48,
	0x8d, 0x6d, 0x3c, 0xd3, 0x42, 0x8e, 0x90, 0xeb, 0xe4, 0x04, 0x1c, 0x0d, 0x15, 0x57, 0x74, 0x49,
	0x36, 0xed, 0xd2, 0xd6, 0xf3, 0xfb, 0xf9, 0x69, 0xe6, 0x41, 0x54, 0x56, 0x2f, 0x84, 0x7e, 0x5d,
	0xe4, 0xa8, 0x9d, 0xb7, 0x6c, 0xd5, 0xb9, 0x23, 0xef, 0x72, 0x5d, 0x18, 0x46, 0x6f, 0xb2, 0xa5,
	0x66, 0x24, 0xd6, 0xf9, 0x8a, 0xd8, 0x96, 0x5b, 0x61, 0x3c, 0xb0, 0x8e, 0x0b, 0x6b, 0x28, 0xbc,
	0x48, 0xba, 0x70, 0x3c, 0x5e, 0x18, 0xeb, 0x71, 0x9e, 0xf4, 0xa0, 0x3b, 0xa9, 0x52, 0x7c, 0x5f,
	0x21, 0x71, 0xd2, 0x07, 0xd8, 0x1c, 0xc8, 0x59, 0x43, 0x98, 0x00, 0xc8, 0x49, 0xf5, 0xe4, 0xe6,
	0x19, 0xe3, 0xed, 0xd7, 0xd1, 0x46, 0x37, 0x0b, 0x76, 0xea, 0x0d, 0xba, 0x8f, 0xd6, 0x97, 0xd9,
	0x32, 0x9d, 0x3e, 0xa8, 0x2b, 0xfd, 0x27, 0x5f, 0xff, 0x22, 0xe2, 0xeb, 0x96, 0xea, 0xf0, 0x07,
	0x45, 0xd0, 0x1f, 0x1b, 0x46, 0x43, 0xc5, 0x1a, 0xf7, 0x0d, 0x4b, 0x3a, 0x4d, 0x2d, 0xfe, 0x9d,
	0x09, 0x65, 0x41, 0x8e, 0x90, 0x67, 0x9c, 0x31, 0x1d, 0x00, 0x28, 0x85, 0xfa, 0x80, 0x93, 0x11,
	0x72, 0x8a, 0x8b, 0xc2, 0x9a, 0x03, 0x60, 0x65, 0x53, 0x8b, 0xff, 0x52, 0x0c, 0x85, 0x72, 0x30,
	0x98, 0x7a, 0x9b, 0x23, 0x51, 0x98, 0xb3, 0xba, 0x68, 0xe1, 0xb4, 0x5d, 0x9d, 0xf8, 0xb2, 0x15,
	0x35, 0x18, 0x87, 0xa8, 0x91, 0x50, 0x9f, 0x70, 0x1a, 0x6e, 0x76, 0x69, 0xf7, 0x48, 0x85, 0xa6,
	0x16, 0x1d, 0x29, 0x22, 0x31, 0x14, 0xf7, 0x83, 0xe7, 0xde, 0xcd, 0xae, 0x3b, 0xaf, 0x9d, 0x9f,
	0x2a, 0xdc, 0x7d, 0x07, 0x00, 0x00, 0xff, 0xff, 0xee, 0x5b, 0x87, 0x9b, 0x50, 0x03, 0x00, 0x00,
}
